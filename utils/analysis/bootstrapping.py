import numpy as np
import pandas as pd
from scipy.stats import norm

from .preprocessing import standardize_data

# Number of bootstrap samples
N_SAMPLES = 1000

# Causal effect measures
DIFFERENCE = 'difference'
RATIO = 'ratio'

# Confidence interval size
CONFIDENCE = 0.95


def bootstrap(
    data: pd.DataFrame,
    compute_effects_func,
    n_samples=N_SAMPLES,
    standardize=True
):
    '''
    Bootstraps effect estimates with a given number of samples. Returns an
    array of shape (n_samples, 2), where each row contains:
        (E[Y | A = 0], E[Y | A = 1])
    for each sample.
    '''
    boostrap_data = data.copy()
    # Standardize the covariates if specified
    if standardize:
        standardize_data(boostrap_data)

    results = []

    for _ in np.arange(n_samples):
        # Generate random bootstrap sample
        sample = boostrap_data.sample(
            frac=1, replace=True
        ).reset_index(drop=True)

        # Function returns (E[Y | A = 0], E[Y | A = 1])
        results.append(compute_effects_func(sample))

    return np.asarray(results)


def compute_effect_measure(
    results: np.ndarray,
    effect_measure=DIFFERENCE,
    confidence=0.95
):
    '''
    Given the results generated by bootstrap sampling, calculates an estimate
    for the given effect measure, as well as a confidence interval of
    specified size.
    '''
    # Assert that results array is in the proper shape
    assert results.ndim == 2
    assert results.shape[1] == 2

    # Compute the specified effect measure for all samples
    if effect_measure == DIFFERENCE:
        # E[Y | A = 1] - E[Y | A = 0]
        effects = results.T[1] - results.T[0]
    elif effect_measure == RATIO:
        # E[Y | A = 1] / E[Y | A = 0]
        effects = results.T[1] / results.T[0]
    else:
        raise Exception(f'Unknown effect measure: {effect_measure}')

    # Causal effect estimate
    mean = np.mean(effects)
    # Standard deviation consistently estimates standard error of effect
    # estimate in the study population
    std_error = np.std(effects)

    # Calculate confidence interval based on given confidence level
    interval_radius = std_error * norm.ppf(0.5 + confidence / 2)
    interval_low = mean - interval_radius
    interval_high = mean + interval_radius

    return mean, (interval_low, interval_high)
